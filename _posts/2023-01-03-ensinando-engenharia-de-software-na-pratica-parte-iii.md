---
title:  "Ensinando Engenharia de Software na Prática, Parte III"
header:
  teaser: "https://farm5.staticflickr.com/4076/4940499208_b79b77fb0a_z.jpg"
header:
  image: https://github.com/vinicius3w/vinicius3w.github.io/blob/master/images/header-by-jesus-kiteque-224069.jpg?raw=true
  caption: "Photo credit: @ikukevk on [**Unsplash**](https://unsplash.com/photos/w7ZyuGYNpRQ)"
categories: 
  - Education
tags:
  - software engineering
  - cloud computing
  - teaching
  - platform engineering
  - digital engineering
  - software product engineering
  - software architecture
  - software testing
  - software quality
  - software engineer
---

Ao longo dos últimos anos me envolvi em projetos de produção de produtos de [software complexo e de larga escala](https://doi.org/10.1145/2209249.2209268), que demandavam pesquisa aplicada para a resolução de problemas reais da indústria.

Por reais quero dizer que são demandas, ou anseios, de clientes, usuários, mercados, fornecedores, _C-level_ de empresas, enfim, _stakeholders_ em geral. Todos são máquinas geradoras do que podemos chamar de **estressores**.

De 2013 a 2020 atuei como pesquisador associado na [Ustore](https://ustore.com.br/) e estive envolvido em pesquisa & desenvolvimento de uma plataforma escalável de armazenamento distribuído de dados (_Software Defined Storages_) para gerenciar, armazenar, indexar e manipular arquivos, objetos e dados, plataforma multicloud de orquestração para fornecer, gerenciar e cobrar IaaS na nuvem pública (i.e. Amazon AWS, Microsoft Azure e Google Cloud) e ambientes privados (i.e. VMware vSphere, Citrix XenServer e Openstack) e no planejamento, desenvolvimento e implementação de soluções técnicas para implantar aplicações em ambientes de alta disponibilidade e tolerantes a falhas usando clusters Kubernetes e containers Docker.

Foram projetos que me ajudaram demais a expandir o meu entendimento (junto com muitos questionamentos) sobre o que era discutido e lecionado (note que não disse ensinado!) nas disciplinas de Engenharia de Software que eu tinha acesso/contato ([em especial a sob minha responsabilidade](https://bit.ly/vcg-es)). Essas experiências me incentivaram a criar as disciplinas: [Serviços e Infraestruturas de Nuvem](http://bit.ly/IF1006-2017-1), [Desenvolvimento de Aplicações Nativas da Nuvem com Arquitetura Baseada em Microservices](https://bit.ly/vcg-microservices) e [Desmistificando DevOps: Projetando Arquiteturas Efetivamente Escaláveis](https://bit.ly/vcg-devops).

A multidisciplinaridade atual da carreira na Engenharia de Software está mais do que clara! Nem vou abrir um debate sobre isso, software é meio e temos fortes interrelações com Banco de Dados, Redes, Sistemas Distribuídos e cada vez mais com Inteligência Artificial e as suas sub-áreas: Ciência de Dados, Aprendizado de Máquina, Redes Neurais, Aprendizado Profundo, etc. Tivemos até o nascimento e crescimento acelerado de coisas como [MLOps](https://blog.nvidia.com.br/2020/09/08/o-que-e-mlops/).

Pois bem, o ponto é que as disciplinas de Engenharia de Software, no geral, têm um foco muito forte em questões sociais (ou humanas), processos, qualidade... mas temos pouco foco em questões de produto, arquitetura e questões mais relacionadas ao **valor que deve ser entregue como um produto de software**.

## O que é a Engenharia de Software?

Ou o que deve ser o foco do que deveríamos ensinar - ou fortalecer as habilidades e capacidades - nas jornadas de ensino e aprendizagem da Engenharia de Software?

O projeto, criação e manutenção (ou evolução) de sistemas de software é (ou deveria ser) a ênfase da disciplina da Ciência da Computação conhecida como Engenharia de Software. Ela envolve o uso de métodos, processos, ferramentas, princípios e conceitos de **engenharia** no desenvolvimento de software, a fim de criar software de **alta qualidade, confiável e de fácil manutenção**.

Diversas e mutifacetadas tarefas estão envolvidas na Engenharia de Software, como a elicitação, especificação e análise de requisitos, projeto e implementação, teste e solução de problemas, implantação e manutenção de software. A fim de apoiar o processo de desenvolvimento de software, é fundamental também envolver o uso de numerosas ferramentas e procedimentos, incluindo sistemas de controle de versão, ferramentas de depuração e estruturas de teste e **garantia da qualidade do que é produzido**.

A criação de software que satisfaça as necessidades de seus usuários e stakeholders em geral é um dos principais objetivos da Engenharia de Software, senão o **principal** objetivo. Isto implica em determinar os requisitos do software e criar uma solução que os satisfaça. Implica também em testar o software para garantir que ele satisfaça os padrões de qualidade necessários e opere como pretendido.

Os engenheiros de software precisam de fortes habilidades de resolução de problemas e comunicação (daí a importância do foco nas questões levantadas anteriormente e que comumente são o foco de disciplinas), além de sua experiência técnica, a fim de operar bem em equipe e interagir com clientes e outros stakeholders.

Mas, para além disso, foram surgindo outras engenharias ao longo dos anos. E é sobre elas que eu acho relevante falar e entender como podemos e devemos levar elas para nossas jornadas de ensino e aprendizagem, como educadores.

E é sobre isso que estou estudando para o design de uma disciplina que pretendo oferta lá no [CIn](https://www.cin.ufpe.br/), em breve. Unindo a Engenharia de Software coisas como Design, Engenharia Digital, Engenharia de Plataforma, Engenharia de Produtos de Software e claro, a sempre bem vinda Arquitetura de Software.

Esse papo continua em outros artigos que virão a seguir...
